{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! FixedColumns 3.3.1\n * Â©2010-2020 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     FixedColumns\n * @description Freeze columns in place on a scrolling DataTable\n * @version     3.3.1\n * @file        dataTables.fixedColumns.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2010-2020 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery', 'datatables.net'], function ($) {\n      return factory($, window, document);\n    });\n  } else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    // CommonJS\n    module.exports = function (root, $) {\n      if (!root) {\n        root = window;\n      }\n\n      if (!$ || !$.fn.dataTable) {\n        $ = require('datatables.net')(root, $).$;\n      }\n\n      return factory($, root, root.document);\n    };\n  } else {\n    // Browser\n    factory(jQuery, window, document);\n  }\n})(function ($, window, document, undefined) {\n  'use strict';\n\n  var DataTable = $.fn.dataTable;\n\n  var _firefoxScroll;\n  /**\n   * When making use of DataTables' x-axis scrolling feature, you may wish to\n   * fix the left most column in place. This plug-in for DataTables provides\n   * exactly this option (note for non-scrolling tables, please use the\n   * FixedHeader plug-in, which can fix headers and footers). Key\n   * features include:\n   *\n   * * Freezes the left or right most columns to the side of the table\n   * * Option to freeze two or more columns\n   * * Full integration with DataTables' scrolling options\n   * * Speed - FixedColumns is fast in its operation\n   *\n   *  @class\n   *  @constructor\n   *  @global\n   *  @param {object} dt DataTables instance. With DataTables 1.10 this can also\n   *    be a jQuery collection, a jQuery selector, DataTables API instance or\n   *    settings object.\n   *  @param {object} [init={}] Configuration object for FixedColumns. Options are\n   *    defined by {@link FixedColumns.defaults}\n   *\n   *  @requires jQuery 1.7+\n   *  @requires DataTables 1.8.0+\n   *\n   *  @example\n   *      var table = $('#example').dataTable( {\n   *        \"scrollX\": \"100%\"\n   *      } );\n   *      new $.fn.dataTable.fixedColumns( table );\n   */\n\n\n  var FixedColumns = function FixedColumns(dt, init) {\n    var that = this;\n    /* Sanity check - you just know it will happen */\n\n    if (!(this instanceof FixedColumns)) {\n      alert(\"FixedColumns warning: FixedColumns must be initialised with the 'new' keyword.\");\n      return;\n    }\n\n    if (init === undefined || init === true) {\n      init = {};\n    } // Use the DataTables Hungarian notation mapping method, if it exists to\n    // provide forwards compatibility for camel case variables\n\n\n    var camelToHungarian = $.fn.dataTable.camelToHungarian;\n\n    if (camelToHungarian) {\n      camelToHungarian(FixedColumns.defaults, FixedColumns.defaults, true);\n      camelToHungarian(FixedColumns.defaults, init);\n    } // v1.10 allows the settings object to be got form a number of sources\n\n\n    var dtSettings = new $.fn.dataTable.Api(dt).settings()[0];\n    /**\n     * Settings object which contains customisable information for FixedColumns instance\n     * @namespace\n     * @extends FixedColumns.defaults\n     * @private\n     */\n\n    this.s = {\n      /**\n       * DataTables settings objects\n       *  @type     object\n       *  @default  Obtained from DataTables instance\n       */\n      \"dt\": dtSettings,\n\n      /**\n       * Number of columns in the DataTable - stored for quick access\n       *  @type     int\n       *  @default  Obtained from DataTables instance\n       */\n      \"iTableColumns\": dtSettings.aoColumns.length,\n\n      /**\n       * Original outer widths of the columns as rendered by DataTables - used to calculate\n       * the FixedColumns grid bounding box\n       *  @type     array.<int>\n       *  @default  []\n       */\n      \"aiOuterWidths\": [],\n\n      /**\n       * Original inner widths of the columns as rendered by DataTables - used to apply widths\n       * to the columns\n       *  @type     array.<int>\n       *  @default  []\n       */\n      \"aiInnerWidths\": [],\n\n      /**\n       * Is the document layout right-to-left\n       * @type boolean\n       */\n      rtl: $(dtSettings.nTable).css('direction') === 'rtl'\n    };\n    /**\n     * DOM elements used by the class instance\n     * @namespace\n     * @private\n     *\n     */\n\n    this.dom = {\n      /**\n       * DataTables scrolling element\n       *  @type     node\n       *  @default  null\n       */\n      \"scroller\": null,\n\n      /**\n       * DataTables header table\n       *  @type     node\n       *  @default  null\n       */\n      \"header\": null,\n\n      /**\n       * DataTables body table\n       *  @type     node\n       *  @default  null\n       */\n      \"body\": null,\n\n      /**\n       * DataTables footer table\n       *  @type     node\n       *  @default  null\n       */\n      \"footer\": null,\n\n      /**\n       * Display grid elements\n       * @namespace\n       */\n      \"grid\": {\n        /**\n         * Grid wrapper. This is the container element for the 3x3 grid\n         *  @type     node\n         *  @default  null\n         */\n        \"wrapper\": null,\n\n        /**\n         * DataTables scrolling element. This element is the DataTables\n         * component in the display grid (making up the main table - i.e.\n         * not the fixed columns).\n         *  @type     node\n         *  @default  null\n         */\n        \"dt\": null,\n\n        /**\n         * Left fixed column grid components\n         * @namespace\n         */\n        \"left\": {\n          \"wrapper\": null,\n          \"head\": null,\n          \"body\": null,\n          \"foot\": null\n        },\n\n        /**\n         * Right fixed column grid components\n         * @namespace\n         */\n        \"right\": {\n          \"wrapper\": null,\n          \"head\": null,\n          \"body\": null,\n          \"foot\": null\n        }\n      },\n\n      /**\n       * Cloned table nodes\n       * @namespace\n       */\n      \"clone\": {\n        /**\n         * Left column cloned table nodes\n         * @namespace\n         */\n        \"left\": {\n          /**\n           * Cloned header table\n           *  @type     node\n           *  @default  null\n           */\n          \"header\": null,\n\n          /**\n           * Cloned body table\n           *  @type     node\n           *  @default  null\n           */\n          \"body\": null,\n\n          /**\n           * Cloned footer table\n           *  @type     node\n           *  @default  null\n           */\n          \"footer\": null\n        },\n\n        /**\n         * Right column cloned table nodes\n         * @namespace\n         */\n        \"right\": {\n          /**\n           * Cloned header table\n           *  @type     node\n           *  @default  null\n           */\n          \"header\": null,\n\n          /**\n           * Cloned body table\n           *  @type     node\n           *  @default  null\n           */\n          \"body\": null,\n\n          /**\n           * Cloned footer table\n           *  @type     node\n           *  @default  null\n           */\n          \"footer\": null\n        }\n      }\n    };\n\n    if (dtSettings._oFixedColumns) {\n      throw 'FixedColumns already initialised on this table';\n    }\n    /* Attach the instance to the DataTables instance so it can be accessed easily */\n\n\n    dtSettings._oFixedColumns = this;\n    /* Let's do it */\n\n    if (!dtSettings._bInitComplete) {\n      dtSettings.oApi._fnCallbackReg(dtSettings, 'aoInitComplete', function () {\n        that._fnConstruct(init);\n      }, 'FixedColumns');\n    } else {\n      this._fnConstruct(init);\n    }\n  };\n\n  $.extend(FixedColumns.prototype, {\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Public methods\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Update the fixed columns - including headers and footers. Note that FixedColumns will\n     * automatically update the display whenever the host DataTable redraws.\n     *  @returns {void}\n     *  @example\n     *      var table = $('#example').dataTable( {\n     *          \"scrollX\": \"100%\"\n     *      } );\n     *      var fc = new $.fn.dataTable.fixedColumns( table );\n     *\n     *      // at some later point when the table has been manipulated....\n     *      fc.fnUpdate();\n     */\n    \"fnUpdate\": function fnUpdate() {\n      this._fnDraw(true);\n    },\n\n    /**\n     * Recalculate the resizes of the 3x3 grid that FixedColumns uses for display of the table.\n     * This is useful if you update the width of the table container. Note that FixedColumns will\n     * perform this function automatically when the window.resize event is fired.\n     *  @returns {void}\n     *  @example\n     *      var table = $('#example').dataTable( {\n     *          \"scrollX\": \"100%\"\n     *      } );\n     *      var fc = new $.fn.dataTable.fixedColumns( table );\n     *\n     *      // Resize the table container and then have FixedColumns adjust its layout....\n     *      $('#content').width( 1200 );\n     *      fc.fnRedrawLayout();\n     */\n    \"fnRedrawLayout\": function fnRedrawLayout() {\n      this._fnColCalc();\n\n      this._fnGridLayout();\n\n      this.fnUpdate();\n    },\n\n    /**\n     * Mark a row such that it's height should be recalculated when using 'semiauto' row\n     * height matching. This function will have no effect when 'none' or 'auto' row height\n     * matching is used.\n     *  @param   {Node} nTr TR element that should have it's height recalculated\n     *  @returns {void}\n     *  @example\n     *      var table = $('#example').dataTable( {\n     *          \"scrollX\": \"100%\"\n     *      } );\n     *      var fc = new $.fn.dataTable.fixedColumns( table );\n     *\n     *      // manipulate the table - mark the row as needing an update then update the table\n     *      // this allows the redraw performed by DataTables fnUpdate to recalculate the row\n     *      // height\n     *      fc.fnRecalculateHeight();\n     *      table.fnUpdate( $('#example tbody tr:eq(0)')[0], [\"insert date\", 1, 2, 3 ... ]);\n     */\n    \"fnRecalculateHeight\": function fnRecalculateHeight(nTr) {\n      delete nTr._DTTC_iHeight;\n      nTr.style.height = 'auto';\n    },\n\n    /**\n     * Set the height of a given row - provides cross browser compatibility\n     *  @param   {Node} nTarget TR element that should have it's height recalculated\n     *  @param   {int} iHeight Height in pixels to set\n     *  @returns {void}\n     *  @example\n     *      var table = $('#example').dataTable( {\n     *          \"scrollX\": \"100%\"\n     *      } );\n     *      var fc = new $.fn.dataTable.fixedColumns( table );\n     *\n     *      // You may want to do this after manipulating a row in the fixed column\n     *      fc.fnSetRowHeight( $('#example tbody tr:eq(0)')[0], 50 );\n     */\n    \"fnSetRowHeight\": function fnSetRowHeight(nTarget, iHeight) {\n      nTarget.style.height = iHeight + \"px\";\n    },\n\n    /**\n     * Get data index information about a row or cell in the table body.\n     * This function is functionally identical to fnGetPosition in DataTables,\n     * taking the same parameter (TH, TD or TR node) and returning exactly the\n     * the same information (data index information). THe difference between\n     * the two is that this method takes into account the fixed columns in the\n     * table, so you can pass in nodes from the master table, or the cloned\n     * tables and get the index position for the data in the main table.\n     *  @param {node} node TR, TH or TD element to get the information about\n     *  @returns {int} If nNode is given as a TR, then a single index is \n     *    returned, or if given as a cell, an array of [row index, column index\n     *    (visible), column index (all)] is given.\n     */\n    \"fnGetPosition\": function fnGetPosition(node) {\n      var idx;\n      var inst = this.s.dt.oInstance;\n\n      if (!$(node).parents('.DTFC_Cloned').length) {\n        // Not in a cloned table\n        return inst.fnGetPosition(node);\n      } else {\n        // Its in the cloned table, so need to look up position\n        if (node.nodeName.toLowerCase() === 'tr') {\n          idx = $(node).index();\n          return inst.fnGetPosition($('tr', this.s.dt.nTBody)[idx]);\n        } else {\n          var colIdx = $(node).index();\n          idx = $(node.parentNode).index();\n          var row = inst.fnGetPosition($('tr', this.s.dt.nTBody)[idx]);\n          return [row, colIdx, inst.oApi._fnVisibleToColumnIndex(this.s.dt, colIdx)];\n        }\n      }\n    },\n    fnToFixedNode: function fnToFixedNode(rowIdx, colIdx) {\n      var found;\n\n      if (colIdx < this.s.iLeftColumns) {\n        found = $(this.dom.clone.left.body).find('[data-dt-row=' + rowIdx + '][data-dt-column=' + colIdx + ']');\n      } else if (colIdx >= this.s.iRightColumns) {\n        found = $(this.dom.clone.right.body).find('[data-dt-row=' + rowIdx + '][data-dt-column=' + colIdx + ']');\n      }\n\n      if (found && found.length) {\n        return found[0];\n      } // Fallback - non-fixed node\n\n\n      var table = new $.fn.dataTable.Api(this.s.dt);\n      return table.cell(rowIdx, colIdx).node();\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Private methods (they are of course public in JS, but recommended as private)\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Initialisation for FixedColumns\n     *  @param   {Object} oInit User settings for initialisation\n     *  @returns {void}\n     *  @private\n     */\n    \"_fnConstruct\": function _fnConstruct(oInit) {\n      var i,\n          iLen,\n          iWidth,\n          that = this;\n      /* Sanity checking */\n\n      if (typeof this.s.dt.oInstance.fnVersionCheck != 'function' || this.s.dt.oInstance.fnVersionCheck('1.8.0') !== true) {\n        alert(\"FixedColumns \" + FixedColumns.VERSION + \" required DataTables 1.8.0 or later. \" + \"Please upgrade your DataTables installation\");\n        return;\n      }\n\n      if (this.s.dt.oScroll.sX === \"\") {\n        this.s.dt.oInstance.oApi._fnLog(this.s.dt, 1, \"FixedColumns is not needed (no \" + \"x-scrolling in DataTables enabled), so no action will be taken. Use 'FixedHeader' for \" + \"column fixing when scrolling is not enabled\");\n\n        return;\n      }\n      /* Apply the settings from the user / defaults */\n\n\n      this.s = $.extend(true, this.s, FixedColumns.defaults, oInit);\n      /* Set up the DOM as we need it and cache nodes */\n\n      var classes = this.s.dt.oClasses;\n      this.dom.grid.dt = $(this.s.dt.nTable).parents('div.' + classes.sScrollWrapper)[0];\n      this.dom.scroller = $('div.' + classes.sScrollBody, this.dom.grid.dt)[0];\n      /* Set up the DOM that we want for the fixed column layout grid */\n\n      this._fnColCalc();\n\n      this._fnGridSetup();\n      /* Event handlers */\n\n\n      var mouseController;\n      var mouseDown = false; // When the mouse is down (drag scroll) the mouse controller cannot\n      // change, as the browser keeps the original element as the scrolling one\n\n      $(this.s.dt.nTableWrapper).on('mousedown.DTFC', function (e) {\n        if (e.button === 0) {\n          mouseDown = true;\n          $(document).one('mouseup', function () {\n            mouseDown = false;\n          });\n        }\n      }); // When the body is scrolled - scroll the left and right columns\n\n      $(this.dom.scroller).on('mouseover.DTFC touchstart.DTFC', function () {\n        if (!mouseDown) {\n          mouseController = 'main';\n        }\n      }).on('scroll.DTFC', function (e) {\n        if (!mouseController && e.originalEvent) {\n          mouseController = 'main';\n        }\n\n        if (mouseController === 'main' || mouseController === 'key') {\n          if (that.s.iLeftColumns > 0) {\n            that.dom.grid.left.liner.scrollTop = that.dom.scroller.scrollTop;\n          }\n\n          if (that.s.iRightColumns > 0) {\n            that.dom.grid.right.liner.scrollTop = that.dom.scroller.scrollTop;\n          }\n        }\n      });\n      var wheelType = 'onwheel' in document.createElement('div') ? 'wheel.DTFC' : 'mousewheel.DTFC';\n\n      if (that.s.iLeftColumns > 0) {\n        // When scrolling the left column, scroll the body and right column\n        $(that.dom.grid.left.liner).on('mouseover.DTFC touchstart.DTFC', function () {\n          if (!mouseDown && mouseController !== 'key') {\n            mouseController = 'left';\n          }\n        }).on('scroll.DTFC', function (e) {\n          if (!mouseController && e.originalEvent) {\n            mouseController = 'left';\n          }\n\n          if (mouseController === 'left') {\n            that.dom.scroller.scrollTop = that.dom.grid.left.liner.scrollTop;\n\n            if (that.s.iRightColumns > 0) {\n              that.dom.grid.right.liner.scrollTop = that.dom.grid.left.liner.scrollTop;\n            }\n          }\n        }).on(wheelType, function (e) {\n          mouseController = 'left'; // Pass horizontal scrolling through\n\n          var xDelta = e.type === 'wheel' ? -e.originalEvent.deltaX : e.originalEvent.wheelDeltaX;\n          that.dom.scroller.scrollLeft -= xDelta;\n        });\n      }\n\n      if (that.s.iRightColumns > 0) {\n        // When scrolling the right column, scroll the body and the left column\n        $(that.dom.grid.right.liner).on('mouseover.DTFC touchstart.DTFC', function () {\n          if (!mouseDown && mouseController !== 'key') {\n            mouseController = 'right';\n          }\n        }).on('scroll.DTFC', function (e) {\n          if (!mouseController && e.originalEvent) {\n            mouseController = 'right';\n          }\n\n          if (mouseController === 'right') {\n            that.dom.scroller.scrollTop = that.dom.grid.right.liner.scrollTop;\n\n            if (that.s.iLeftColumns > 0) {\n              that.dom.grid.left.liner.scrollTop = that.dom.grid.right.liner.scrollTop;\n            }\n          }\n        }).on(wheelType, function (e) {\n          mouseController = 'left'; // Pass horizontal scrolling through\n\n          var xDelta = e.type === 'wheel' ? -e.originalEvent.deltaX : e.originalEvent.wheelDeltaX;\n          that.dom.scroller.scrollLeft -= xDelta;\n        });\n      }\n\n      $(window).on('resize.DTFC', function () {\n        that._fnGridLayout.call(that);\n      });\n      var bFirstDraw = true;\n      var jqTable = $(this.s.dt.nTable);\n      jqTable.on('draw.dt.DTFC', function () {\n        that._fnColCalc();\n\n        that._fnDraw.call(that, bFirstDraw);\n\n        bFirstDraw = false;\n      }).on('key-focus.dt.DTFC', function () {\n        // KeyTable navigation needs to be main focused\n        mouseController = 'key';\n      }).on('column-sizing.dt.DTFC', function () {\n        that._fnColCalc();\n\n        that._fnGridLayout(that);\n      }).on('column-visibility.dt.DTFC', function (e, settings, column, vis, recalc) {\n        if (recalc === undefined || recalc) {\n          that._fnColCalc();\n\n          that._fnGridLayout(that);\n\n          that._fnDraw(true);\n        }\n      }).on('select.dt.DTFC deselect.dt.DTFC', function (e, dt, type, indexes) {\n        if (e.namespace === 'dt') {\n          that._fnDraw(false);\n        }\n      }).on('position.dts.dt.DTFC', function (e, tableTop) {\n        // Sync up with Scroller\n        if (that.dom.grid.left.body) {\n          $(that.dom.grid.left.body).find('table').eq(0).css('top', tableTop);\n        }\n\n        if (that.dom.grid.right.body) {\n          $(that.dom.grid.right.body).find('table').eq(0).css('top', tableTop);\n        }\n      }).on('destroy.dt.DTFC', function () {\n        jqTable.off('.DTFC');\n        $(that.dom.scroller).off('.DTFC');\n        $(window).off('.DTFC');\n        $(that.s.dt.nTableWrapper).off('.DTFC');\n        $(that.dom.grid.left.liner).off('.DTFC ' + wheelType);\n        $(that.dom.grid.left.wrapper).remove();\n        $(that.dom.grid.right.liner).off('.DTFC ' + wheelType);\n        $(that.dom.grid.right.wrapper).remove();\n      });\n      /* Get things right to start with - note that due to adjusting the columns, there must be\n       * another redraw of the main table. It doesn't need to be a full redraw however.\n       */\n\n      this._fnGridLayout();\n\n      this.s.dt.oInstance.fnDraw(false);\n    },\n\n    /**\n     * Calculate the column widths for the grid layout\n     *  @returns {void}\n     *  @private\n     */\n    \"_fnColCalc\": function _fnColCalc() {\n      var that = this;\n      var iLeftWidth = 0;\n      var iRightWidth = 0;\n      this.s.aiInnerWidths = [];\n      this.s.aiOuterWidths = [];\n      $.each(this.s.dt.aoColumns, function (i, col) {\n        var th = $(col.nTh);\n        var border;\n\n        if (!th.filter(':visible').length) {\n          that.s.aiInnerWidths.push(0);\n          that.s.aiOuterWidths.push(0);\n        } else {\n          // Inner width is used to assign widths to cells\n          // Outer width is used to calculate the container\n          var iWidth = th.outerWidth(); // When working with the left most-cell, need to add on the\n          // table's border to the outerWidth, since we need to take\n          // account of it, but it isn't in any cell\n\n          if (that.s.aiOuterWidths.length === 0) {\n            border = $(that.s.dt.nTable).css('border-left-width');\n            iWidth += typeof border === 'string' && border.indexOf('px') === -1 ? 1 : parseInt(border, 10);\n          } // Likewise with the final column on the right\n\n\n          if (that.s.aiOuterWidths.length === that.s.dt.aoColumns.length - 1) {\n            border = $(that.s.dt.nTable).css('border-right-width');\n            iWidth += typeof border === 'string' && border.indexOf('px') === -1 ? 1 : parseInt(border, 10);\n          }\n\n          that.s.aiOuterWidths.push(iWidth);\n          that.s.aiInnerWidths.push(th.width());\n\n          if (i < that.s.iLeftColumns) {\n            iLeftWidth += iWidth;\n          }\n\n          if (that.s.iTableColumns - that.s.iRightColumns <= i) {\n            iRightWidth += iWidth;\n          }\n        }\n      });\n      this.s.iLeftWidth = iLeftWidth;\n      this.s.iRightWidth = iRightWidth;\n    },\n\n    /**\n     * Set up the DOM for the fixed column. The way the layout works is to create a 1x3 grid\n     * for the left column, the DataTable (for which we just reuse the scrolling element DataTable\n     * puts into the DOM) and the right column. In each of he two fixed column elements there is a\n     * grouping wrapper element and then a head, body and footer wrapper. In each of these we then\n     * place the cloned header, body or footer tables. This effectively gives as 3x3 grid structure.\n     *  @returns {void}\n     *  @private\n     */\n    \"_fnGridSetup\": function _fnGridSetup() {\n      var that = this;\n\n      var oOverflow = this._fnDTOverflow();\n\n      var block;\n      this.dom.body = this.s.dt.nTable;\n      this.dom.header = this.s.dt.nTHead.parentNode;\n      this.dom.header.parentNode.parentNode.style.position = \"relative\";\n      var nSWrapper = $('<div class=\"DTFC_ScrollWrapper\" style=\"position:relative; clear:both;\">' + '<div class=\"DTFC_LeftWrapper\" style=\"position:absolute; top:0; left:0;\" aria-hidden=\"true\">' + '<div class=\"DTFC_LeftHeadWrapper\" style=\"position:relative; top:0; left:0; overflow:hidden;\"></div>' + '<div class=\"DTFC_LeftBodyWrapper\" style=\"position:relative; top:0; left:0; height:0; overflow:hidden;\">' + '<div class=\"DTFC_LeftBodyLiner\" style=\"position:relative; top:0; left:0; overflow-y:scroll;\"></div>' + '</div>' + '<div class=\"DTFC_LeftFootWrapper\" style=\"position:relative; top:0; left:0; overflow:hidden;\"></div>' + '</div>' + '<div class=\"DTFC_RightWrapper\" style=\"position:absolute; top:0; right:0;\" aria-hidden=\"true\">' + '<div class=\"DTFC_RightHeadWrapper\" style=\"position:relative; top:0; left:0;\">' + '<div class=\"DTFC_RightHeadBlocker DTFC_Blocker\" style=\"position:absolute; top:0; bottom:0;\"></div>' + '</div>' + '<div class=\"DTFC_RightBodyWrapper\" style=\"position:relative; top:0; left:0; height:0; overflow:hidden;\">' + '<div class=\"DTFC_RightBodyLiner\" style=\"position:relative; top:0; left:0; overflow-y:scroll;\"></div>' + '</div>' + '<div class=\"DTFC_RightFootWrapper\" style=\"position:relative; top:0; left:0;\">' + '<div class=\"DTFC_RightFootBlocker DTFC_Blocker\" style=\"position:absolute; top:0; bottom:0;\"></div>' + '</div>' + '</div>' + '</div>')[0];\n      var nLeft = nSWrapper.childNodes[0];\n      var nRight = nSWrapper.childNodes[1];\n      this.dom.grid.dt.parentNode.insertBefore(nSWrapper, this.dom.grid.dt);\n      nSWrapper.appendChild(this.dom.grid.dt);\n      this.dom.grid.wrapper = nSWrapper;\n\n      if (this.s.iLeftColumns > 0) {\n        this.dom.grid.left.wrapper = nLeft;\n        this.dom.grid.left.head = nLeft.childNodes[0];\n        this.dom.grid.left.body = nLeft.childNodes[1];\n        this.dom.grid.left.liner = $('div.DTFC_LeftBodyLiner', nSWrapper)[0];\n        nSWrapper.appendChild(nLeft);\n      }\n\n      if (this.s.iRightColumns > 0) {\n        this.dom.grid.right.wrapper = nRight;\n        this.dom.grid.right.head = nRight.childNodes[0];\n        this.dom.grid.right.body = nRight.childNodes[1];\n        this.dom.grid.right.liner = $('div.DTFC_RightBodyLiner', nSWrapper)[0];\n        nRight.style.right = oOverflow.bar + \"px\";\n        block = $('div.DTFC_RightHeadBlocker', nSWrapper)[0];\n        block.style.width = oOverflow.bar + \"px\";\n        block.style.right = -oOverflow.bar + \"px\";\n        this.dom.grid.right.headBlock = block;\n        block = $('div.DTFC_RightFootBlocker', nSWrapper)[0];\n        block.style.width = oOverflow.bar + \"px\";\n        block.style.right = -oOverflow.bar + \"px\";\n        this.dom.grid.right.footBlock = block;\n        nSWrapper.appendChild(nRight);\n      }\n\n      if (this.s.dt.nTFoot) {\n        this.dom.footer = this.s.dt.nTFoot.parentNode;\n\n        if (this.s.iLeftColumns > 0) {\n          this.dom.grid.left.foot = nLeft.childNodes[2];\n        }\n\n        if (this.s.iRightColumns > 0) {\n          this.dom.grid.right.foot = nRight.childNodes[2];\n        }\n      } // RTL support - swap the position of the left and right columns (#48)\n\n\n      if (this.s.rtl) {\n        $('div.DTFC_RightHeadBlocker', nSWrapper).css({\n          left: -oOverflow.bar + 'px',\n          right: ''\n        });\n      }\n    },\n\n    /**\n     * Style and position the grid used for the FixedColumns layout\n     *  @returns {void}\n     *  @private\n     */\n    \"_fnGridLayout\": function _fnGridLayout() {\n      var that = this;\n      var oGrid = this.dom.grid;\n      var iWidth = $(oGrid.wrapper).width();\n      var iBodyHeight = this.s.dt.nTable.parentNode.offsetHeight;\n      var iFullHeight = this.s.dt.nTable.parentNode.parentNode.offsetHeight;\n\n      var oOverflow = this._fnDTOverflow();\n\n      var iLeftWidth = this.s.iLeftWidth;\n      var iRightWidth = this.s.iRightWidth;\n      var rtl = $(this.dom.body).css('direction') === 'rtl';\n      var wrapper;\n\n      var scrollbarAdjust = function scrollbarAdjust(node, width) {\n        if (!oOverflow.bar) {\n          // If there is no scrollbar (Macs) we need to hide the auto scrollbar\n          node.style.width = width + 20 + \"px\";\n          node.style.paddingRight = \"20px\";\n          node.style.boxSizing = \"border-box\";\n        } else if (that._firefoxScrollError()) {\n          // See the above function for why this is required\n          if ($(node).height() > 34) {\n            node.style.width = width + oOverflow.bar + \"px\";\n          }\n        } else {\n          // Otherwise just overflow by the scrollbar\n          node.style.width = width + oOverflow.bar + \"px\";\n        }\n      }; // When x scrolling - don't paint the fixed columns over the x scrollbar\n\n\n      if (oOverflow.x) {\n        iBodyHeight -= oOverflow.bar;\n      }\n\n      oGrid.wrapper.style.height = iFullHeight + \"px\";\n\n      if (this.s.iLeftColumns > 0) {\n        wrapper = oGrid.left.wrapper;\n        wrapper.style.width = iLeftWidth + 'px';\n        wrapper.style.height = '1px'; // Swap the position of the left and right columns for rtl (#48)\n        // This is always up against the edge, scrollbar on the far side\n\n        if (rtl) {\n          wrapper.style.left = '';\n          wrapper.style.right = 0;\n        } else {\n          wrapper.style.left = 0;\n          wrapper.style.right = '';\n        }\n\n        oGrid.left.body.style.height = iBodyHeight + \"px\";\n\n        if (oGrid.left.foot) {\n          oGrid.left.foot.style.top = (oOverflow.x ? oOverflow.bar : 0) + \"px\"; // shift footer for scrollbar\n        }\n\n        scrollbarAdjust(oGrid.left.liner, iLeftWidth);\n        oGrid.left.liner.style.height = iBodyHeight + \"px\";\n        oGrid.left.liner.style.maxHeight = iBodyHeight + \"px\";\n      }\n\n      if (this.s.iRightColumns > 0) {\n        wrapper = oGrid.right.wrapper;\n        wrapper.style.width = iRightWidth + 'px';\n        wrapper.style.height = '1px'; // Need to take account of the vertical scrollbar\n\n        if (this.s.rtl) {\n          wrapper.style.left = oOverflow.y ? oOverflow.bar + 'px' : 0;\n          wrapper.style.right = '';\n        } else {\n          wrapper.style.left = '';\n          wrapper.style.right = oOverflow.y ? oOverflow.bar + 'px' : 0;\n        }\n\n        oGrid.right.body.style.height = iBodyHeight + \"px\";\n\n        if (oGrid.right.foot) {\n          oGrid.right.foot.style.top = (oOverflow.x ? oOverflow.bar : 0) + \"px\";\n        }\n\n        scrollbarAdjust(oGrid.right.liner, iRightWidth);\n        oGrid.right.liner.style.height = iBodyHeight + \"px\";\n        oGrid.right.liner.style.maxHeight = iBodyHeight + \"px\";\n        oGrid.right.headBlock.style.display = oOverflow.y ? 'block' : 'none';\n        oGrid.right.footBlock.style.display = oOverflow.y ? 'block' : 'none';\n      }\n    },\n\n    /**\n     * Get information about the DataTable's scrolling state - specifically if the table is scrolling\n     * on either the x or y axis, and also the scrollbar width.\n     *  @returns {object} Information about the DataTables scrolling state with the properties:\n     *    'x', 'y' and 'bar'\n     *  @private\n     */\n    \"_fnDTOverflow\": function _fnDTOverflow() {\n      var nTable = this.s.dt.nTable;\n      var nTableScrollBody = nTable.parentNode;\n      var out = {\n        \"x\": false,\n        \"y\": false,\n        \"bar\": this.s.dt.oScroll.iBarWidth\n      };\n\n      if (nTable.offsetWidth > nTableScrollBody.clientWidth) {\n        out.x = true;\n      }\n\n      if (nTable.offsetHeight > nTableScrollBody.clientHeight) {\n        out.y = true;\n      }\n\n      return out;\n    },\n\n    /**\n     * Clone and position the fixed columns\n     *  @returns {void}\n     *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)\n     *  @private\n     */\n    \"_fnDraw\": function _fnDraw(bAll) {\n      this._fnGridLayout();\n\n      this._fnCloneLeft(bAll);\n\n      this._fnCloneRight(bAll);\n      /* Draw callback function */\n\n\n      if (this.s.fnDrawCallback !== null) {\n        this.s.fnDrawCallback.call(this, this.dom.clone.left, this.dom.clone.right);\n      }\n      /* Event triggering */\n\n\n      $(this).trigger('draw.dtfc', {\n        \"leftClone\": this.dom.clone.left,\n        \"rightClone\": this.dom.clone.right\n      });\n    },\n\n    /**\n     * Clone the right columns\n     *  @returns {void}\n     *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)\n     *  @private\n     */\n    \"_fnCloneRight\": function _fnCloneRight(bAll) {\n      if (this.s.iRightColumns <= 0) {\n        return;\n      }\n\n      var that = this,\n          i,\n          jq,\n          aiColumns = [];\n\n      for (i = this.s.iTableColumns - this.s.iRightColumns; i < this.s.iTableColumns; i++) {\n        if (this.s.dt.aoColumns[i].bVisible) {\n          aiColumns.push(i);\n        }\n      }\n\n      this._fnClone(this.dom.clone.right, this.dom.grid.right, aiColumns, bAll);\n    },\n\n    /**\n     * Clone the left columns\n     *  @returns {void}\n     *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)\n     *  @private\n     */\n    \"_fnCloneLeft\": function _fnCloneLeft(bAll) {\n      if (this.s.iLeftColumns <= 0) {\n        return;\n      }\n\n      var that = this,\n          i,\n          jq,\n          aiColumns = [];\n\n      for (i = 0; i < this.s.iLeftColumns; i++) {\n        if (this.s.dt.aoColumns[i].bVisible) {\n          aiColumns.push(i);\n        }\n      }\n\n      this._fnClone(this.dom.clone.left, this.dom.grid.left, aiColumns, bAll);\n    },\n\n    /**\n     * Make a copy of the layout object for a header or footer element from DataTables. Note that\n     * this method will clone the nodes in the layout object.\n     *  @returns {Array} Copy of the layout array\n     *  @param   {Object} aoOriginal Layout array from DataTables (aoHeader or aoFooter)\n     *  @param   {Object} aiColumns Columns to copy\n     *  @param   {boolean} events Copy cell events or not\n     *  @private\n     */\n    \"_fnCopyLayout\": function _fnCopyLayout(aoOriginal, aiColumns, events) {\n      var aReturn = [];\n      var aClones = [];\n      var aCloned = [];\n\n      for (var i = 0, iLen = aoOriginal.length; i < iLen; i++) {\n        var aRow = [];\n        aRow.nTr = $(aoOriginal[i].nTr).clone(events, false)[0];\n\n        for (var j = 0, jLen = this.s.iTableColumns; j < jLen; j++) {\n          if ($.inArray(j, aiColumns) === -1) {\n            continue;\n          }\n\n          var iCloned = $.inArray(aoOriginal[i][j].cell, aCloned);\n\n          if (iCloned === -1) {\n            var nClone = $(aoOriginal[i][j].cell).clone(events, false)[0];\n            aClones.push(nClone);\n            aCloned.push(aoOriginal[i][j].cell);\n            aRow.push({\n              \"cell\": nClone,\n              \"unique\": aoOriginal[i][j].unique\n            });\n          } else {\n            aRow.push({\n              \"cell\": aClones[iCloned],\n              \"unique\": aoOriginal[i][j].unique\n            });\n          }\n        }\n\n        aReturn.push(aRow);\n      }\n\n      return aReturn;\n    },\n\n    /**\n     * Clone the DataTable nodes and place them in the DOM (sized correctly)\n     *  @returns {void}\n     *  @param   {Object} oClone Object containing the header, footer and body cloned DOM elements\n     *  @param   {Object} oGrid Grid object containing the display grid elements for the cloned\n     *                    column (left or right)\n     *  @param   {Array} aiColumns Column indexes which should be operated on from the DataTable\n     *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)\n     *  @private\n     */\n    \"_fnClone\": function _fnClone(oClone, oGrid, aiColumns, bAll) {\n      var that = this,\n          i,\n          iLen,\n          j,\n          jLen,\n          jq,\n          nTarget,\n          iColumn,\n          nClone,\n          iIndex,\n          aoCloneLayout,\n          jqCloneThead,\n          aoFixedHeader,\n          dt = this.s.dt;\n      /*\n       * Header\n       */\n\n      if (bAll) {\n        $(oClone.header).remove();\n        oClone.header = $(this.dom.header).clone(true, false)[0];\n        oClone.header.className += \" DTFC_Cloned\";\n        oClone.header.style.width = \"100%\";\n        oGrid.head.appendChild(oClone.header);\n        /* Copy the DataTables layout cache for the header for our floating column */\n\n        aoCloneLayout = this._fnCopyLayout(dt.aoHeader, aiColumns, true);\n        jqCloneThead = $('>thead', oClone.header);\n        jqCloneThead.empty();\n        /* Add the created cloned TR elements to the table */\n\n        for (i = 0, iLen = aoCloneLayout.length; i < iLen; i++) {\n          jqCloneThead[0].appendChild(aoCloneLayout[i].nTr);\n        }\n        /* Use the handy _fnDrawHead function in DataTables to do the rowspan/colspan\n         * calculations for us\n         */\n\n\n        dt.oApi._fnDrawHead(dt, aoCloneLayout, true);\n      } else {\n        /* To ensure that we copy cell classes exactly, regardless of colspan, multiple rows\n         * etc, we make a copy of the header from the DataTable again, but don't insert the\n         * cloned cells, just copy the classes across. To get the matching layout for the\n         * fixed component, we use the DataTables _fnDetectHeader method, allowing 1:1 mapping\n         */\n        aoCloneLayout = this._fnCopyLayout(dt.aoHeader, aiColumns, false);\n        aoFixedHeader = [];\n\n        dt.oApi._fnDetectHeader(aoFixedHeader, $('>thead', oClone.header)[0]);\n\n        for (i = 0, iLen = aoCloneLayout.length; i < iLen; i++) {\n          for (j = 0, jLen = aoCloneLayout[i].length; j < jLen; j++) {\n            aoFixedHeader[i][j].cell.className = aoCloneLayout[i][j].cell.className; // If jQuery UI theming is used we need to copy those elements as well\n\n            $('span.DataTables_sort_icon', aoFixedHeader[i][j].cell).each(function () {\n              this.className = $('span.DataTables_sort_icon', aoCloneLayout[i][j].cell)[0].className;\n            });\n          }\n        }\n      }\n\n      this._fnEqualiseHeights('thead', this.dom.header, oClone.header);\n      /*\n       * Body\n       */\n\n\n      if (this.s.sHeightMatch == 'auto') {\n        /* Remove any heights which have been applied already and let the browser figure it out */\n        $('>tbody>tr', that.dom.body).css('height', 'auto');\n      }\n\n      if (oClone.body !== null) {\n        $(oClone.body).remove();\n        oClone.body = null;\n      }\n\n      oClone.body = $(this.dom.body).clone(true)[0];\n      oClone.body.className += \" DTFC_Cloned\";\n      oClone.body.style.paddingBottom = dt.oScroll.iBarWidth + \"px\";\n      oClone.body.style.marginBottom = dt.oScroll.iBarWidth * 2 + \"px\";\n      /* For IE */\n\n      if (oClone.body.getAttribute('id') !== null) {\n        oClone.body.removeAttribute('id');\n      }\n\n      $('>thead>tr', oClone.body).empty();\n      $('>tfoot', oClone.body).remove();\n      var nBody = $('tbody', oClone.body)[0];\n      $(nBody).empty();\n\n      if (dt.aiDisplay.length > 0) {\n        /* Copy the DataTables' header elements to force the column width in exactly the\n         * same way that DataTables does it - have the header element, apply the width and\n         * colapse it down\n         */\n        var nInnerThead = $('>thead>tr', oClone.body)[0];\n\n        for (iIndex = 0; iIndex < aiColumns.length; iIndex++) {\n          iColumn = aiColumns[iIndex];\n          nClone = $(dt.aoColumns[iColumn].nTh).clone(true)[0];\n          nClone.innerHTML = \"\";\n          var oStyle = nClone.style;\n          oStyle.paddingTop = \"0\";\n          oStyle.paddingBottom = \"0\";\n          oStyle.borderTopWidth = \"0\";\n          oStyle.borderBottomWidth = \"0\";\n          oStyle.height = 0;\n          oStyle.width = that.s.aiInnerWidths[iColumn] + \"px\";\n          nInnerThead.appendChild(nClone);\n        }\n        /* Add in the tbody elements, cloning form the master table */\n\n\n        $('>tbody>tr', that.dom.body).each(function (z) {\n          var i = that.s.dt.oFeatures.bServerSide === false ? that.s.dt.aiDisplay[that.s.dt._iDisplayStart + z] : z;\n          var aTds = that.s.dt.aoData[i].anCells || $(this).children('td, th');\n          var n = this.cloneNode(false);\n          n.removeAttribute('id');\n          n.setAttribute('data-dt-row', i);\n\n          for (iIndex = 0; iIndex < aiColumns.length; iIndex++) {\n            iColumn = aiColumns[iIndex];\n\n            if (aTds.length > 0) {\n              nClone = $(aTds[iColumn]).clone(true, true)[0];\n              nClone.removeAttribute('id');\n              nClone.setAttribute('data-dt-row', i);\n              nClone.setAttribute('data-dt-column', iColumn);\n              n.appendChild(nClone);\n            }\n          }\n\n          nBody.appendChild(n);\n        });\n      } else {\n        $('>tbody>tr', that.dom.body).each(function (z) {\n          nClone = this.cloneNode(true);\n          nClone.className += ' DTFC_NoData';\n          $('td', nClone).html('');\n          nBody.appendChild(nClone);\n        });\n      }\n\n      oClone.body.style.width = \"100%\";\n      oClone.body.style.margin = \"0\";\n      oClone.body.style.padding = \"0\"; // Interop with Scroller - need to use a height forcing element in the\n      // scrolling area in the same way that Scroller does in the body scroll.\n\n      if (dt.oScroller !== undefined) {\n        var scrollerForcer = dt.oScroller.dom.force;\n\n        if (!oGrid.forcer) {\n          oGrid.forcer = scrollerForcer.cloneNode(true);\n          oGrid.liner.appendChild(oGrid.forcer);\n        } else {\n          oGrid.forcer.style.height = scrollerForcer.style.height;\n        }\n      }\n\n      oGrid.liner.appendChild(oClone.body);\n\n      this._fnEqualiseHeights('tbody', that.dom.body, oClone.body);\n      /*\n       * Footer\n       */\n\n\n      if (dt.nTFoot !== null) {\n        if (bAll) {\n          if (oClone.footer !== null) {\n            oClone.footer.parentNode.removeChild(oClone.footer);\n          }\n\n          oClone.footer = $(this.dom.footer).clone(true, true)[0];\n          oClone.footer.className += \" DTFC_Cloned\";\n          oClone.footer.style.width = \"100%\";\n          oGrid.foot.appendChild(oClone.footer);\n          /* Copy the footer just like we do for the header */\n\n          aoCloneLayout = this._fnCopyLayout(dt.aoFooter, aiColumns, true);\n          var jqCloneTfoot = $('>tfoot', oClone.footer);\n          jqCloneTfoot.empty();\n\n          for (i = 0, iLen = aoCloneLayout.length; i < iLen; i++) {\n            jqCloneTfoot[0].appendChild(aoCloneLayout[i].nTr);\n          }\n\n          dt.oApi._fnDrawHead(dt, aoCloneLayout, true);\n        } else {\n          aoCloneLayout = this._fnCopyLayout(dt.aoFooter, aiColumns, false);\n          var aoCurrFooter = [];\n\n          dt.oApi._fnDetectHeader(aoCurrFooter, $('>tfoot', oClone.footer)[0]);\n\n          for (i = 0, iLen = aoCloneLayout.length; i < iLen; i++) {\n            for (j = 0, jLen = aoCloneLayout[i].length; j < jLen; j++) {\n              aoCurrFooter[i][j].cell.className = aoCloneLayout[i][j].cell.className;\n            }\n          }\n        }\n\n        this._fnEqualiseHeights('tfoot', this.dom.footer, oClone.footer);\n      }\n      /* Equalise the column widths between the header footer and body - body get's priority */\n\n\n      var anUnique = dt.oApi._fnGetUniqueThs(dt, $('>thead', oClone.header)[0]);\n\n      $(anUnique).each(function (i) {\n        iColumn = aiColumns[i];\n        this.style.width = that.s.aiInnerWidths[iColumn] + \"px\";\n      });\n\n      if (that.s.dt.nTFoot !== null) {\n        anUnique = dt.oApi._fnGetUniqueThs(dt, $('>tfoot', oClone.footer)[0]);\n        $(anUnique).each(function (i) {\n          iColumn = aiColumns[i];\n          this.style.width = that.s.aiInnerWidths[iColumn] + \"px\";\n        });\n      }\n    },\n\n    /**\n     * From a given table node (THEAD etc), get a list of TR direct child elements\n     *  @param   {Node} nIn Table element to search for TR elements (THEAD, TBODY or TFOOT element)\n     *  @returns {Array} List of TR elements found\n     *  @private\n     */\n    \"_fnGetTrNodes\": function _fnGetTrNodes(nIn) {\n      var aOut = [];\n\n      for (var i = 0, iLen = nIn.childNodes.length; i < iLen; i++) {\n        if (nIn.childNodes[i].nodeName.toUpperCase() == \"TR\") {\n          aOut.push(nIn.childNodes[i]);\n        }\n      }\n\n      return aOut;\n    },\n\n    /**\n     * Equalise the heights of the rows in a given table node in a cross browser way\n     *  @returns {void}\n     *  @param   {String} nodeName Node type - thead, tbody or tfoot\n     *  @param   {Node} original Original node to take the heights from\n     *  @param   {Node} clone Copy the heights to\n     *  @private\n     */\n    \"_fnEqualiseHeights\": function _fnEqualiseHeights(nodeName, original, clone) {\n      if (this.s.sHeightMatch == 'none' && nodeName !== 'thead' && nodeName !== 'tfoot') {\n        return;\n      }\n\n      var that = this,\n          i,\n          iLen,\n          iHeight,\n          iHeight2,\n          iHeightOriginal,\n          iHeightClone,\n          rootOriginal = original.getElementsByTagName(nodeName)[0],\n          rootClone = clone.getElementsByTagName(nodeName)[0],\n          jqBoxHack = $('>' + nodeName + '>tr:eq(0)', original).children(':first'),\n          iBoxHack = jqBoxHack.outerHeight() - jqBoxHack.height(),\n          anOriginal = this._fnGetTrNodes(rootOriginal),\n          anClone = this._fnGetTrNodes(rootClone),\n          heights = [];\n\n      for (i = 0, iLen = anClone.length; i < iLen; i++) {\n        iHeightOriginal = anOriginal[i].offsetHeight;\n        iHeightClone = anClone[i].offsetHeight;\n        iHeight = iHeightClone > iHeightOriginal ? iHeightClone : iHeightOriginal;\n\n        if (this.s.sHeightMatch == 'semiauto') {\n          anOriginal[i]._DTTC_iHeight = iHeight;\n        }\n\n        heights.push(iHeight);\n      }\n\n      for (i = 0, iLen = anClone.length; i < iLen; i++) {\n        anClone[i].style.height = heights[i] + \"px\";\n        anOriginal[i].style.height = heights[i] + \"px\";\n      }\n    },\n\n    /**\n     * Determine if the UA suffers from Firefox's overflow:scroll scrollbars\n     * not being shown bug.\n     *\n     * Firefox doesn't draw scrollbars, even if it is told to using\n     * overflow:scroll, if the div is less than 34px height. See bugs 292284 and\n     * 781885. Using UA detection here since this is particularly hard to detect\n     * using objects - its a straight up rendering error in Firefox.\n     *\n     * @return {boolean} True if Firefox error is present, false otherwise\n     */\n    _firefoxScrollError: function _firefoxScrollError() {\n      if (_firefoxScroll === undefined) {\n        var test = $('<div/>').css({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          height: 10,\n          width: 50,\n          overflow: 'scroll'\n        }).appendTo('body'); // Make sure this doesn't apply on Macs with 0 width scrollbars\n\n        _firefoxScroll = test[0].clientWidth === test[0].offsetWidth && this._fnDTOverflow().bar !== 0;\n        test.remove();\n      }\n\n      return _firefoxScroll;\n    }\n  });\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Statics\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * FixedColumns default settings for initialisation\n   *  @name FixedColumns.defaults\n   *  @namespace\n   *  @static\n   */\n\n  FixedColumns.defaults =\n  /** @lends FixedColumns.defaults */\n  {\n    /**\n     * Number of left hand columns to fix in position\n     *  @type     int\n     *  @default  1\n     *  @static\n     *  @example\n     *      var  = $('#example').dataTable( {\n     *          \"scrollX\": \"100%\"\n     *      } );\n     *      new $.fn.dataTable.fixedColumns( table, {\n     *          \"leftColumns\": 2\n     *      } );\n     */\n    \"iLeftColumns\": 1,\n\n    /**\n     * Number of right hand columns to fix in position\n     *  @type     int\n     *  @default  0\n     *  @static\n     *  @example\n     *      var table = $('#example').dataTable( {\n     *          \"scrollX\": \"100%\"\n     *      } );\n     *      new $.fn.dataTable.fixedColumns( table, {\n     *          \"rightColumns\": 1\n     *      } );\n     */\n    \"iRightColumns\": 0,\n\n    /**\n     * Draw callback function which is called when FixedColumns has redrawn the fixed assets\n     *  @type     function(object, object):void\n     *  @default  null\n     *  @static\n     *  @example\n     *      var table = $('#example').dataTable( {\n     *          \"scrollX\": \"100%\"\n     *      } );\n     *      new $.fn.dataTable.fixedColumns( table, {\n     *          \"drawCallback\": function () {\n     *\t            alert( \"FixedColumns redraw\" );\n     *\t        }\n     *      } );\n     */\n    \"fnDrawCallback\": null,\n\n    /**\n     * Height matching algorthim to use. This can be \"none\" which will result in no height\n     * matching being applied by FixedColumns (height matching could be forced by CSS in this\n     * case), \"semiauto\" whereby the height calculation will be performed once, and the result\n     * cached to be used again (fnRecalculateHeight can be used to force recalculation), or\n     * \"auto\" when height matching is performed on every draw (slowest but must accurate)\n     *  @type     string\n     *  @default  semiauto\n     *  @static\n     *  @example\n     *      var table = $('#example').dataTable( {\n     *          \"scrollX\": \"100%\"\n     *      } );\n     *      new $.fn.dataTable.fixedColumns( table, {\n     *          \"heightMatch\": \"auto\"\n     *      } );\n     */\n    \"sHeightMatch\": \"semiauto\"\n  };\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Constants\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * FixedColumns version\n   *  @name      FixedColumns.version\n   *  @type      String\n   *  @default   See code\n   *  @static\n   */\n\n  FixedColumns.version = \"3.3.1\";\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * DataTables API integration\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  DataTable.Api.register('fixedColumns()', function () {\n    return this;\n  });\n  DataTable.Api.register('fixedColumns().update()', function () {\n    return this.iterator('table', function (ctx) {\n      if (ctx._oFixedColumns) {\n        ctx._oFixedColumns.fnUpdate();\n      }\n    });\n  });\n  DataTable.Api.register('fixedColumns().relayout()', function () {\n    return this.iterator('table', function (ctx) {\n      if (ctx._oFixedColumns) {\n        ctx._oFixedColumns.fnRedrawLayout();\n      }\n    });\n  });\n  DataTable.Api.register('rows().recalcHeight()', function () {\n    return this.iterator('row', function (ctx, idx) {\n      if (ctx._oFixedColumns) {\n        ctx._oFixedColumns.fnRecalculateHeight(this.row(idx).node());\n      }\n    });\n  });\n  DataTable.Api.register('fixedColumns().rowIndex()', function (row) {\n    row = $(row);\n    return row.parents('.DTFC_Cloned').length ? this.rows({\n      page: 'current'\n    }).indexes()[row.index()] : this.row(row).index();\n  });\n  DataTable.Api.register('fixedColumns().cellIndex()', function (cell) {\n    cell = $(cell);\n\n    if (cell.parents('.DTFC_Cloned').length) {\n      var rowClonedIdx = cell.parent().index();\n      var rowIdx = this.rows({\n        page: 'current'\n      }).indexes()[rowClonedIdx];\n      var columnIdx;\n\n      if (cell.parents('.DTFC_LeftWrapper').length) {\n        columnIdx = cell.index();\n      } else {\n        var columns = this.columns().flatten().length;\n        columnIdx = columns - this.context[0]._oFixedColumns.s.iRightColumns + cell.index();\n      }\n\n      return {\n        row: rowIdx,\n        column: this.column.index('toData', columnIdx),\n        columnVisible: columnIdx\n      };\n    } else {\n      return this.cell(cell).index();\n    }\n  });\n  DataTable.Api.registerPlural('cells().fixedNodes()', 'cell().fixedNode()', function () {\n    return this.iterator('cell', function (settings, row, column) {\n      return settings._oFixedColumns ? settings._oFixedColumns.fnToFixedNode(row, column) : this.cell(row, column).node();\n    }, 1);\n  });\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Initialisation\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n  // Attach a listener to the document which listens for DataTables initialisation\n  // events so we can automatically initialise\n\n  $(document).on('init.dt.fixedColumns', function (e, settings) {\n    if (e.namespace !== 'dt') {\n      return;\n    }\n\n    var init = settings.oInit.fixedColumns;\n    var defaults = DataTable.defaults.fixedColumns;\n\n    if (init || defaults) {\n      var opts = $.extend({}, init, defaults);\n\n      if (init !== false) {\n        new FixedColumns(settings, opts);\n      }\n    }\n  }); // Make FixedColumns accessible from the DataTables instance\n\n  $.fn.dataTable.FixedColumns = FixedColumns;\n  $.fn.DataTable.FixedColumns = FixedColumns;\n  return FixedColumns;\n});","map":null,"metadata":{},"sourceType":"module"}