{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! FixedHeader 3.1.7\n * Â©2009-2020 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     FixedHeader\n * @description Fix a table's header or footer, so it is always visible while\n *              scrolling\n * @version     3.1.7\n * @file        dataTables.fixedHeader.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2009-2020 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery', 'datatables.net'], function ($) {\n      return factory($, window, document);\n    });\n  } else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    // CommonJS\n    module.exports = function (root, $) {\n      if (!root) {\n        root = window;\n      }\n\n      if (!$ || !$.fn.dataTable) {\n        $ = require('datatables.net')(root, $).$;\n      }\n\n      return factory($, root, root.document);\n    };\n  } else {\n    // Browser\n    factory(jQuery, window, document);\n  }\n})(function ($, window, document, undefined) {\n  'use strict';\n\n  var DataTable = $.fn.dataTable;\n  var _instCounter = 0;\n\n  var FixedHeader = function FixedHeader(dt, config) {\n    // Sanity check - you just know it will happen\n    if (!(this instanceof FixedHeader)) {\n      throw \"FixedHeader must be initialised with the 'new' keyword.\";\n    } // Allow a boolean true for defaults\n\n\n    if (config === true) {\n      config = {};\n    }\n\n    dt = new DataTable.Api(dt);\n    this.c = $.extend(true, {}, FixedHeader.defaults, config);\n    this.s = {\n      dt: dt,\n      position: {\n        theadTop: 0,\n        tbodyTop: 0,\n        tfootTop: 0,\n        tfootBottom: 0,\n        width: 0,\n        left: 0,\n        tfootHeight: 0,\n        theadHeight: 0,\n        windowHeight: $(window).height(),\n        visible: true\n      },\n      headerMode: null,\n      footerMode: null,\n      autoWidth: dt.settings()[0].oFeatures.bAutoWidth,\n      namespace: '.dtfc' + _instCounter++,\n      scrollLeft: {\n        header: -1,\n        footer: -1\n      },\n      enable: true\n    };\n    this.dom = {\n      floatingHeader: null,\n      thead: $(dt.table().header()),\n      tbody: $(dt.table().body()),\n      tfoot: $(dt.table().footer()),\n      header: {\n        host: null,\n        floating: null,\n        placeholder: null\n      },\n      footer: {\n        host: null,\n        floating: null,\n        placeholder: null\n      }\n    };\n    this.dom.header.host = this.dom.thead.parent();\n    this.dom.footer.host = this.dom.tfoot.parent();\n    var dtSettings = dt.settings()[0];\n\n    if (dtSettings._fixedHeader) {\n      throw \"FixedHeader already initialised on table \" + dtSettings.nTable.id;\n    }\n\n    dtSettings._fixedHeader = this;\n\n    this._constructor();\n  };\n  /*\n   * Variable: FixedHeader\n   * Purpose:  Prototype for FixedHeader\n   * Scope:    global\n   */\n\n\n  $.extend(FixedHeader.prototype, {\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * API methods\n     */\n\n    /**\n     * Kill off FH and any events\n     */\n    destroy: function destroy() {\n      this.s.dt.off('.dtfc');\n      $(window).off(this.s.namespace);\n\n      if (this.c.header) {\n        this._modeChange('in-place', 'header', true);\n      }\n\n      if (this.c.footer && this.dom.tfoot.length) {\n        this._modeChange('in-place', 'footer', true);\n      }\n    },\n\n    /**\n     * Enable / disable the fixed elements\n     *\n     * @param  {boolean} enable `true` to enable, `false` to disable\n     */\n    enable: function enable(_enable, update) {\n      this.s.enable = _enable;\n\n      if (update || update === undefined) {\n        this._positions();\n\n        this._scroll(true);\n      }\n    },\n\n    /**\n     * Get enabled status\n     */\n    enabled: function enabled() {\n      return this.s.enable;\n    },\n\n    /**\n     * Set header offset \n     *\n     * @param  {int} new value for headerOffset\n     */\n    headerOffset: function headerOffset(offset) {\n      if (offset !== undefined) {\n        this.c.headerOffset = offset;\n        this.update();\n      }\n\n      return this.c.headerOffset;\n    },\n\n    /**\n     * Set footer offset\n     *\n     * @param  {int} new value for footerOffset\n     */\n    footerOffset: function footerOffset(offset) {\n      if (offset !== undefined) {\n        this.c.footerOffset = offset;\n        this.update();\n      }\n\n      return this.c.footerOffset;\n    },\n\n    /**\n     * Recalculate the position of the fixed elements and force them into place\n     */\n    update: function update() {\n      var table = this.s.dt.table().node();\n\n      if ($(table).is(':visible')) {\n        this.enable(true, false);\n      } else {\n        this.enable(false, false);\n      }\n\n      this._positions();\n\n      this._scroll(true);\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Constructor\n     */\n\n    /**\n     * FixedHeader constructor - adding the required event listeners and\n     * simple initialisation\n     *\n     * @private\n     */\n    _constructor: function _constructor() {\n      var that = this;\n      var dt = this.s.dt;\n      $(window).on('scroll' + this.s.namespace, function () {\n        that._scroll();\n      }).on('resize' + this.s.namespace, DataTable.util.throttle(function () {\n        that.s.position.windowHeight = $(window).height();\n        that.update();\n      }, 50));\n      var autoHeader = $('.fh-fixedHeader');\n\n      if (!this.c.headerOffset && autoHeader.length) {\n        this.c.headerOffset = autoHeader.outerHeight();\n      }\n\n      var autoFooter = $('.fh-fixedFooter');\n\n      if (!this.c.footerOffset && autoFooter.length) {\n        this.c.footerOffset = autoFooter.outerHeight();\n      }\n\n      dt.on('column-reorder.dt.dtfc column-visibility.dt.dtfc draw.dt.dtfc column-sizing.dt.dtfc responsive-display.dt.dtfc', function () {\n        that.update();\n      });\n      dt.on('destroy.dtfc', function () {\n        that.destroy();\n      });\n\n      this._positions();\n\n      this._scroll();\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Private methods\n     */\n\n    /**\n     * Clone a fixed item to act as a place holder for the original element\n     * which is moved into a clone of the table element, and moved around the\n     * document to give the fixed effect.\n     *\n     * @param  {string}  item  'header' or 'footer'\n     * @param  {boolean} force Force the clone to happen, or allow automatic\n     *   decision (reuse existing if available)\n     * @private\n     */\n    _clone: function _clone(item, force) {\n      var dt = this.s.dt;\n      var itemDom = this.dom[item];\n      var itemElement = item === 'header' ? this.dom.thead : this.dom.tfoot;\n\n      if (!force && itemDom.floating) {\n        // existing floating element - reuse it\n        itemDom.floating.removeClass('fixedHeader-floating fixedHeader-locked');\n      } else {\n        if (itemDom.floating) {\n          itemDom.placeholder.remove();\n\n          this._unsize(item);\n\n          itemDom.floating.children().detach();\n          itemDom.floating.remove();\n        }\n\n        itemDom.floating = $(dt.table().node().cloneNode(false)).css('table-layout', 'fixed').attr('aria-hidden', 'true').removeAttr('id').append(itemElement).appendTo('body'); // Insert a fake thead/tfoot into the DataTable to stop it jumping around\n\n        itemDom.placeholder = itemElement.clone(false);\n        itemDom.placeholder.find('*[id]').removeAttr('id');\n        itemDom.host.prepend(itemDom.placeholder); // Clone widths\n\n        this._matchWidths(itemDom.placeholder, itemDom.floating);\n      }\n    },\n\n    /**\n     * Copy widths from the cells in one element to another. This is required\n     * for the footer as the footer in the main table takes its sizes from the\n     * header columns. That isn't present in the footer so to have it still\n     * align correctly, the sizes need to be copied over. It is also required\n     * for the header when auto width is not enabled\n     *\n     * @param  {jQuery} from Copy widths from\n     * @param  {jQuery} to   Copy widths to\n     * @private\n     */\n    _matchWidths: function _matchWidths(from, to) {\n      var get = function get(name) {\n        return $(name, from).map(function () {\n          return $(this).width();\n        }).toArray();\n      };\n\n      var set = function set(name, toWidths) {\n        $(name, to).each(function (i) {\n          $(this).css({\n            width: toWidths[i],\n            minWidth: toWidths[i]\n          });\n        });\n      };\n\n      var thWidths = get('th');\n      var tdWidths = get('td');\n      set('th', thWidths);\n      set('td', tdWidths);\n    },\n\n    /**\n     * Remove assigned widths from the cells in an element. This is required\n     * when inserting the footer back into the main table so the size is defined\n     * by the header columns and also when auto width is disabled in the\n     * DataTable.\n     *\n     * @param  {string} item The `header` or `footer`\n     * @private\n     */\n    _unsize: function _unsize(item) {\n      var el = this.dom[item].floating;\n\n      if (el && (item === 'footer' || item === 'header' && !this.s.autoWidth)) {\n        $('th, td', el).css({\n          width: '',\n          minWidth: ''\n        });\n      } else if (el && item === 'header') {\n        $('th, td', el).css('min-width', '');\n      }\n    },\n\n    /**\n     * Reposition the floating elements to take account of horizontal page\n     * scroll\n     *\n     * @param  {string} item       The `header` or `footer`\n     * @param  {int}    scrollLeft Document scrollLeft\n     * @private\n     */\n    _horizontal: function _horizontal(item, scrollLeft) {\n      var itemDom = this.dom[item];\n      var position = this.s.position;\n      var lastScrollLeft = this.s.scrollLeft;\n\n      if (itemDom.floating && lastScrollLeft[item] !== scrollLeft) {\n        itemDom.floating.css('left', position.left - scrollLeft);\n        lastScrollLeft[item] = scrollLeft;\n      }\n    },\n\n    /**\n     * Change from one display mode to another. Each fixed item can be in one\n     * of:\n     *\n     * * `in-place` - In the main DataTable\n     * * `in` - Floating over the DataTable\n     * * `below` - (Header only) Fixed to the bottom of the table body\n     * * `above` - (Footer only) Fixed to the top of the table body\n     * \n     * @param  {string}  mode        Mode that the item should be shown in\n     * @param  {string}  item        'header' or 'footer'\n     * @param  {boolean} forceChange Force a redraw of the mode, even if already\n     *     in that mode.\n     * @private\n     */\n    _modeChange: function _modeChange(mode, item, forceChange) {\n      var dt = this.s.dt;\n      var itemDom = this.dom[item];\n      var position = this.s.position; // It isn't trivial to add a !important css attribute...\n\n      var importantWidth = function importantWidth(w) {\n        itemDom.floating.attr('style', function (i, s) {\n          return (s || '') + 'width: ' + w + 'px !important;';\n        });\n      }; // Record focus. Browser's will cause input elements to loose focus if\n      // they are inserted else where in the doc\n\n\n      var tablePart = this.dom[item === 'footer' ? 'tfoot' : 'thead'];\n      var focus = $.contains(tablePart[0], document.activeElement) ? document.activeElement : null;\n\n      if (focus) {\n        focus.blur();\n      }\n\n      if (mode === 'in-place') {\n        // Insert the header back into the table's real header\n        if (itemDom.placeholder) {\n          itemDom.placeholder.remove();\n          itemDom.placeholder = null;\n        }\n\n        this._unsize(item);\n\n        if (item === 'header') {\n          itemDom.host.prepend(tablePart);\n        } else {\n          itemDom.host.append(tablePart);\n        }\n\n        if (itemDom.floating) {\n          itemDom.floating.remove();\n          itemDom.floating = null;\n        }\n      } else if (mode === 'in') {\n        // Remove the header from the read header and insert into a fixed\n        // positioned floating table clone\n        this._clone(item, forceChange);\n\n        itemDom.floating.addClass('fixedHeader-floating').css(item === 'header' ? 'top' : 'bottom', this.c[item + 'Offset']).css('left', position.left + 'px');\n        importantWidth(position.width);\n\n        if (item === 'footer') {\n          itemDom.floating.css('top', '');\n        }\n      } else if (mode === 'below') {\n        // only used for the header\n        // Fix the position of the floating header at base of the table body\n        this._clone(item, forceChange);\n\n        itemDom.floating.addClass('fixedHeader-locked').css('top', position.tfootTop - position.theadHeight).css('left', position.left + 'px');\n        importantWidth(position.width);\n      } else if (mode === 'above') {\n        // only used for the footer\n        // Fix the position of the floating footer at top of the table body\n        this._clone(item, forceChange);\n\n        itemDom.floating.addClass('fixedHeader-locked').css('top', position.tbodyTop).css('left', position.left + 'px');\n        importantWidth(position.width);\n      } // Restore focus if it was lost\n\n\n      if (focus && focus !== document.activeElement) {\n        setTimeout(function () {\n          focus.focus();\n        }, 10);\n      }\n\n      this.s.scrollLeft.header = -1;\n      this.s.scrollLeft.footer = -1;\n      this.s[item + 'Mode'] = mode;\n    },\n\n    /**\n     * Cache the positional information that is required for the mode\n     * calculations that FixedHeader performs.\n     *\n     * @private\n     */\n    _positions: function _positions() {\n      var dt = this.s.dt;\n      var table = dt.table();\n      var position = this.s.position;\n      var dom = this.dom;\n      var tableNode = $(table.node()); // Need to use the header and footer that are in the main table,\n      // regardless of if they are clones, since they hold the positions we\n      // want to measure from\n\n      var thead = tableNode.children('thead');\n      var tfoot = tableNode.children('tfoot');\n      var tbody = dom.tbody;\n      position.visible = tableNode.is(':visible');\n      position.width = tableNode.outerWidth();\n      position.left = tableNode.offset().left;\n      position.theadTop = thead.offset().top;\n      position.tbodyTop = tbody.offset().top;\n      position.tbodyHeight = tbody.outerHeight();\n      position.theadHeight = position.tbodyTop - position.theadTop;\n\n      if (tfoot.length) {\n        position.tfootTop = tfoot.offset().top;\n        position.tfootBottom = position.tfootTop + tfoot.outerHeight();\n        position.tfootHeight = position.tfootBottom - position.tfootTop;\n      } else {\n        position.tfootTop = position.tbodyTop + tbody.outerHeight();\n        position.tfootBottom = position.tfootTop;\n        position.tfootHeight = position.tfootTop;\n      }\n    },\n\n    /**\n     * Mode calculation - determine what mode the fixed items should be placed\n     * into.\n     *\n     * @param  {boolean} forceChange Force a redraw of the mode, even if already\n     *     in that mode.\n     * @private\n     */\n    _scroll: function _scroll(forceChange) {\n      var windowTop = $(document).scrollTop();\n      var windowLeft = $(document).scrollLeft();\n      var position = this.s.position;\n      var headerMode, footerMode;\n\n      if (this.c.header) {\n        if (!this.s.enable) {\n          headerMode = 'in-place';\n        } else if (!position.visible || windowTop <= position.theadTop - this.c.headerOffset) {\n          headerMode = 'in-place';\n        } else if (windowTop <= position.tfootTop - position.theadHeight - this.c.headerOffset) {\n          headerMode = 'in';\n        } else {\n          headerMode = 'below';\n        }\n\n        if (forceChange || headerMode !== this.s.headerMode) {\n          this._modeChange(headerMode, 'header', forceChange);\n        }\n\n        this._horizontal('header', windowLeft);\n      }\n\n      if (this.c.footer && this.dom.tfoot.length) {\n        if (!this.s.enable) {\n          footerMode = 'in-place';\n        } else if (!position.visible || windowTop + position.windowHeight >= position.tfootBottom + this.c.footerOffset) {\n          footerMode = 'in-place';\n        } else if (position.windowHeight + windowTop > position.tbodyTop + position.tfootHeight + this.c.footerOffset) {\n          footerMode = 'in';\n        } else {\n          footerMode = 'above';\n        }\n\n        if (forceChange || footerMode !== this.s.footerMode) {\n          this._modeChange(footerMode, 'footer', forceChange);\n        }\n\n        this._horizontal('footer', windowLeft);\n      }\n    }\n  });\n  /**\n   * Version\n   * @type {String}\n   * @static\n   */\n\n  FixedHeader.version = \"3.1.7\";\n  /**\n   * Defaults\n   * @type {Object}\n   * @static\n   */\n\n  FixedHeader.defaults = {\n    header: true,\n    footer: false,\n    headerOffset: 0,\n    footerOffset: 0\n  };\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * DataTables interfaces\n   */\n  // Attach for constructor access\n\n  $.fn.dataTable.FixedHeader = FixedHeader;\n  $.fn.DataTable.FixedHeader = FixedHeader; // DataTables creation - check if the FixedHeader option has been defined on the\n  // table and if so, initialise\n\n  $(document).on('init.dt.dtfh', function (e, settings, json) {\n    if (e.namespace !== 'dt') {\n      return;\n    }\n\n    var init = settings.oInit.fixedHeader;\n    var defaults = DataTable.defaults.fixedHeader;\n\n    if ((init || defaults) && !settings._fixedHeader) {\n      var opts = $.extend({}, defaults, init);\n\n      if (init !== false) {\n        new FixedHeader(settings, opts);\n      }\n    }\n  }); // DataTables API methods\n\n  DataTable.Api.register('fixedHeader()', function () {});\n  DataTable.Api.register('fixedHeader.adjust()', function () {\n    return this.iterator('table', function (ctx) {\n      var fh = ctx._fixedHeader;\n\n      if (fh) {\n        fh.update();\n      }\n    });\n  });\n  DataTable.Api.register('fixedHeader.enable()', function (flag) {\n    return this.iterator('table', function (ctx) {\n      var fh = ctx._fixedHeader;\n      flag = flag !== undefined ? flag : true;\n\n      if (fh && flag !== fh.enabled()) {\n        fh.enable(flag);\n      }\n    });\n  });\n  DataTable.Api.register('fixedHeader.enabled()', function () {\n    if (this.context.length) {\n      var fh = this.content[0]._fixedHeader;\n\n      if (fh) {\n        return fh.enabled();\n      }\n    }\n\n    return false;\n  });\n  DataTable.Api.register('fixedHeader.disable()', function () {\n    return this.iterator('table', function (ctx) {\n      var fh = ctx._fixedHeader;\n\n      if (fh && fh.enabled()) {\n        fh.enable(false);\n      }\n    });\n  });\n  $.each(['header', 'footer'], function (i, el) {\n    DataTable.Api.register('fixedHeader.' + el + 'Offset()', function (offset) {\n      var ctx = this.context;\n\n      if (offset === undefined) {\n        return ctx.length && ctx[0]._fixedHeader ? ctx[0]._fixedHeader[el + 'Offset']() : undefined;\n      }\n\n      return this.iterator('table', function (ctx) {\n        var fh = ctx._fixedHeader;\n\n        if (fh) {\n          fh[el + 'Offset'](offset);\n        }\n      });\n    });\n  });\n  return FixedHeader;\n});","map":null,"metadata":{},"sourceType":"module"}